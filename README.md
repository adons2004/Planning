# Planning бэкенд

## 1. Требования

* [.NET 8.0 SDK](https://dotnet.microsoft.com/download/dotnet/8.0)

## 2. Запуск проекта

Для запуска API выполните следующие команды из корневой директории проекта:

```bash
dotnet restore
dotnet run --project Planning.Api
```

После запуска API будет доступно по адресу: [http://localhost:3000](http://localhost:3000)

## 3. Документация API (Swagger)

Swagger UI доступен по адресу:
[http://localhost:3000/swagger](http://localhost:3000/swagger)

## 4. Архитектура

### 4.1. Структура
Данный сервис устроен по принципам onion архитектуры.

- Planning.Domain - содержит всю бизнес логику (в данном случае расчёт, сущности). Решения описаны ниже.
- Planning.Application - содержит юзкейсы, то как мы используем бизнес логику. Применил паттерн CQRS с помощью библиотеки MediatR.
- Planning.Infrastructure - реализация репозиториев и работа с данными (InMemory DB). Используется EF Core.
- Planning.Api - слой Presentation. REST APi, также можно расширять на другой транспорт, grpc, rabbitmq, Kafka, camunda.
- Planning.*.Tests - проекты с тестами для соответствующих слоев.
- Planning.*.Benchmarks - проект с бенчмарками для соответствующих слоев.
  Запуск бенчмарка: ```dotnet run -c Release --project Planning.Domain.Benchmarks```

### 4.2. Описание
Код написан так, чтобы соблюдать принципы SOLID.
- Для добавления нового уровня расчёта нужно унаследоваться от CalculationSku, после чего инициализировать объект.
- Для добавления новой расчётной колонки следует добавить новое свойство в класс CalculationSku и
  реализовать его в дочерних классах по аналогии с `IHistoryY0Parameters` и `IPlanningY1Parameters`.
- Расчёт реализован на основе паттерна Компоновщик. Базовая сущность это абстрактный класс CalculatableSku.
  В нем определяется виртуальное свойство Children, содержащее список дочерних элементов.
  Расчёт происходит рекурсивно, начиная с корневого элемента и проходя по всем дочерним элементам.
